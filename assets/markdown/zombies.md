# Zombies

## Brief
Zombies is a 2D top-down zombie survival game built with a custom engine in Java. The engine was developed from scratch
over the course of the semester, culminating in a 4-week final project to build a game. 

- **Project Type**: Solo

- **Skills**: `Java`, `Game Engine development`, `Sprite creation`, `Pathfinding`, `AI`, `Physics`



<video src="zombies_demo.mp4"> </video>

## Overview
The engine was developed over the course of the semester as part of Brown University's CSCI 1950n - "2D Game Engines" course.
The semester consisted of three 2-week projects and a final project. Using Java and the very primitive rendering tool
"GraphicsContext", the engine was built entirely from scratch. 

The first project was building an Application and Screen management system which allowed for UI elements, user input and basic
game functionality.
The second project built upon this by implementing gameworld logic, basic collision detection and resolution, sprite rendering and AI via decision trees.
The third project implemented physics based movement and collision resolution, along with xml gamestate saving and loading.
Finally, the final project was to build a game upon this engine, implementing any extra features as needed. 
I chose to build a top-down zombie survival game, inspired by COD Zombies and Minecraft which I was currently playing at the time.
The game features navigation mesh based pathfinding, implementing A* and a string-pulling algorithm to create better
pathfinding AI. The game also features a layered sprite system, allowing for more complex character animations and visual effects.

---

## Development log
The purpose of the course was to teach engine development, which meant a design emphasis on generic systems that could 
be reused and extended in future projects. The codebase was separated into an engine package and a game package, with 
the engine containing all the core systems and the game containing all the game-specific logic and assets.

### Project 1: Little Alchemy
The first project was to build "Little Alchemy".
First, an application system was created to manage Screens, user inputs and the game loop.
Next, we implemented a generic screen and UI elements, allowing for rendering and responding to user input.
UI elements were designed to be generalizable, such as a Button class which would trigger a callback when clicked.
Each UI element was responsible for rendering and handling its children, allowing for complex UI hierarchies.
Finally, we implemented a viewport system to allow for conversion between screen and game coordinates, and added simple
collision detection for interacting.
The final result was a simple "Little Alchemy" game, where the player could combine elements to create new ones.

> #### Game screenshot
>
> ![alc.png](/assets/assets/images/projects/zombies/alc.jpg)
### Project 2: Top-down Shooter
The second project was to build a top-down shooter game.
Building upon the first project, we implemented a game world which contained entities and components, allowing for more complex game logic.
Using an object-oriented design, we created a generic Entity class which contains a list of Components, which are 
responsible for different aspects of the entity's behavior and appearance. Each component is designed to be reusable and
game-agnostic, such as a SpriteComponent for rendering, which allows for future games to build upon the already existing
engine systems. We also implemented a decision tree AI system and A-star pathfinding allowing for more complex enemy behavior.

> #### Game screenshot
> 
> ![wiz.png](/assets/assets/images/projects/zombies/wiz.jpg)

### Project 3: Physics-based platformer
The third project was to build a physics-based platformer game.
Building upon the previous projects, we implemented a physics system which allowed for more realistic movement and 
collision resolution. Implementing force and impulses allowed for more complex movement mechanics, such as jumping and knockback. We also implemented a gamestate saving
and loading system using XML, allowing for a generic way to save and load game data which could be extended in future projects.
Finally, we implemented raycasting, allowing for more complex interactions such as shooting and line of sight.
> #### Game screenshot 
> 
> ![nin.png](/assets/assets/images/projects/zombies/nin.png)

### Final Project: Zombies
The final project was an opportunity to build any game we wanted using the engine we had built. 
I chose to build a top-down zombie survival game, inspired by COD Zombies and Minecraft which I was currently playing at the time.
Engine-wise, I implemented a navigation mesh system for pathfinding, which allowed for more complex and efficient pathfinding compared to a grid-based system.
Then I implemented a string-pulling algorithm to smooth out the paths generated by A*, which resulted in more natural movement for the zombies.

> #### Navigation mesh and pathfinding development
>
> ![pathfinding.png](/assets/assets/images/projects/zombies/pathfinding.png)
>

Finally, I implemented a layered sprite system, allowing for more complex character animations and visual effects, such as separate layers for the body and head which could be animated independently.
I ended up spending a tremendous amount of time creating sprite sheets for the player and zombies, which was captured
using BlockBench and a custom macro to cycle through animation frames and armor models.

[//]: # (<img src="/assets/images/projects/zombies/legs_walk.png" alt="sprite sheet" width="200"/>)
> #### Sprite sheet of the walking animation for the legs layer
> 
> ![legs_walk.png](/assets/assets/images/projects/zombies/legs_walk.png)
> 
> #### Head sprite sheet
> 
> ![head.png](/assets/assets/images/projects/zombies/head.png)
> 
Using a custom layered sprite system, I was able to create more complex animations and visual effects. For example, 
the player and zombies have separate layers for the legs, body and head, allowing for independent animation of each layer. 
This allowed for more dynamic and visually interesting characters, as well as the ability to easily add new weapons and
animations in the future. The layered sprite system was paired with an animation controller which handled which frame
to render based on the entity's current state.

---

### Conclusion
Overall, this project was very enjoyable and was an amazing experience to engage in game engine development. 
I feel that building the engine from scratch allowed me to gain a much deeper understanding of how game engines work, 
and in general taught me a lot about software engineering and modular design principles.